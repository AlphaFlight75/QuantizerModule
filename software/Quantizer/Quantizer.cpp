/*
 * Quantizer library
 * Rich Holmes
 * 
 * Based on:
 * TELEXo Eurorack Module
 * (c) 2016, 2017 Brendon Cassidy
 * MIT License
 */
 
//#include "Arduino.h"
#include "Quantizer.h"
//#include "TxHelper.h"

//
// initializes the quantizer and sets the scale to 0 (usually equal temperament)
//
Quantizer::Quantizer() {
  SetScale(0);
}

//
// initializes the quantizer and sets the initial scale
//
Quantizer::Quantizer(int scale) {
  SetScale(scale);  
}

//
// initializes the quantizer and sets the initial scale
//
Quantizer::Quantizer(int bank, int scale)
{
  SetScale(bank, scale);
}

/*
 * change the scale of the quantizer
 */
void Quantizer::SetScale(int scale) {
  if (scale >= 0 && scale < scaleCount)
    {
      _scale = scale;
      _last.Note = 0;
      _last.Value = 0;
 
      _below = 1;
      _above = 0;
    }
}

/*
 * change the scale of the quantizer
 */
void Quantizer::SetScale(int bank, int scale) {
  if (bank < 12 && scale < 12)
    SetScale (pgm_read_word(&bankandscale[bank][scale]));
}

/*
 * quantizes an int (range 0-DACTOP)
 */
QuantizeResponse Quantizer::Quantize(int in) {

  QuantizeResponse response;
  
  // deal with negative values
  in = in < 0 ? -in : in;

  // short circuit if we are within our current bounary
  if (in >= _below && in < _above){
    return _last;
  }
  
  // if not - we need to find where we are in the list
  // hints are a type of skip-list that jumps us to the proper octave
  _octave = (int)(in / DACPEROCTAVE) - 1;
  _octave = _octave > 0 ? _octave : 0;
  
  _index = pgm_read_word (&(hints[_scale][_octave]));
  
  int distance = 32767;
  int distanceTemp = 0;

  // find where we can't get any closer then back out
  while (_index < notecount[_scale]) {
    _temp = in - pgm_read_float (&(scales[_scale][_index]));
    
    distanceTemp = _temp < 0 ? -_temp : _temp;
    
    if (distanceTemp > distance){
      _index--;
      break;
    } else {
      // else increment
      distance = distanceTemp;
      _index++;
    }
    
  }

  // move it down to the next to last if we made it to the end
  if (_index >= notecount[_scale]) 
    _index = notecount[_scale] - 1;

  // use index to quantize
  _current = pgm_read_float (&(scales[_scale][_index])) + 0.5; // rounding

  // set the response
  response.Note = _index;
  response.Value = _current;
  
  _last = response;
  
  // now set the helper boundries
  _above = _index < notecount[_scale] - 1 ? pgm_read_float (&(scales[_scale][_index + 1])) : 32767;
  _below = _index > 0 ? pgm_read_float (&(scales[_scale][_index-1])) : pgm_read_float (&(scales[_scale][_index]));

  // similar to a mutable quantize trick to expand the region slightly
  // had been doing this using floats - thx for the fixed math tip oliver
  _above = ((13 * _current) + (19 * _above)) >> 5;
  _below = ((13 * _current) + (19 * _below)) >> 5;

  // constrain the above and below values
  _above = _above > 32767 ? 32767 : _above;
  _below = _below < 0 ? 0 : _below;

  return response;
  
}

/*
 * returns the values (0-16383) for a note number; 0 if out of range
 */
float Quantizer::GetValueForNote(int note){
  if (note < notecount[_scale])
    return pgm_read_float(&(scales[_scale][note]));
  else
    return 0;
}

// INSERT AUTOGENERATED SCALE CLASS DATA HERE
// scl/RSH_equal_temperament.scl
// Neidhardt IV temperament (1724), equal temperament
const float Quantizer::scale0[] = { 0.0,68.25,136.5,204.75,273.0,341.25,409.5,477.75,546.0,614.25,682.5,750.75,819.0,887.25,955.5,1023.75,1092.0,1160.25,1228.5,1296.75,1365.0,1433.25,1501.5,1569.75,1638.0,1706.25,1774.5,1842.75,1911.0,1979.25,2047.5,2115.75,2184.0,2252.25,2320.5,2388.75,2457.0,2525.25,2593.5,2661.75,2730.0,2798.25,2866.5,2934.75,3003.0,3071.25,3139.5,3207.75,3276.0,3344.25,3412.5,3480.75,3549.0,3617.25,3685.5,3753.75,3822.0,3890.25,3958.5,4026.75,4095.0,4163.25 };
const int Quantizer::hints0[] = { 0,12,24,36,48,60 };
// scl/RSH_etdiat_aolian.scl
// Aolian diatonic in equal temperament
const float Quantizer::scale1[] = { 0.0,136.5,204.75,341.25,477.75,546.0,682.5,819.0,955.5,1023.75,1160.25,1296.75,1365.0,1501.5,1638.0,1774.5,1842.75,1979.25,2115.75,2184.0,2320.5,2457.0,2593.5,2661.75,2798.25,2934.75,3003.0,3139.5,3276.0,3412.5,3480.75,3617.25,3753.75,3822.0,3958.5,4095.0,4231.5 };
const int Quantizer::hints1[] = { 0,7,14,21,28,35 };
// scl/RSH_etdiat_dorian.scl
// Dorian diatonic in equal temperament
const float Quantizer::scale2[] = { 0.0,136.5,204.75,341.25,477.75,614.25,682.5,819.0,955.5,1023.75,1160.25,1296.75,1433.25,1501.5,1638.0,1774.5,1842.75,1979.25,2115.75,2252.25,2320.5,2457.0,2593.5,2661.75,2798.25,2934.75,3071.25,3139.5,3276.0,3412.5,3480.75,3617.25,3753.75,3890.25,3958.5,4095.0,4231.5 };
const int Quantizer::hints2[] = { 0,7,14,21,28,35 };
// scl/RSH_etdiat_ionian.scl
// Ionian diatonic in equal temperament
const float Quantizer::scale3[] = { 0.0,136.5,273.0,341.25,477.75,614.25,750.75,819.0,955.5,1092.0,1160.25,1296.75,1433.25,1569.75,1638.0,1774.5,1911.0,1979.25,2115.75,2252.25,2388.75,2457.0,2593.5,2730.0,2798.25,2934.75,3071.25,3207.75,3276.0,3412.5,3549.0,3617.25,3753.75,3890.25,4026.75,4095.0,4231.5 };
const int Quantizer::hints3[] = { 0,7,14,21,28,35 };
// scl/RSH_etdiat_locrian.scl
// Locrian diatonic in equal temperament
const float Quantizer::scale4[] = { 0.0,68.25,204.75,341.25,409.5,546.0,682.5,819.0,887.25,1023.75,1160.25,1228.5,1365.0,1501.5,1638.0,1706.25,1842.75,1979.25,2047.5,2184.0,2320.5,2457.0,2525.25,2661.75,2798.25,2866.5,3003.0,3139.5,3276.0,3344.25,3480.75,3617.25,3685.5,3822.0,3958.5,4095.0,4163.25 };
const int Quantizer::hints4[] = { 0,7,14,21,28,35 };
// scl/RSH_etdiat_lydian.scl
// Lydian diatonic in equal temperament
const float Quantizer::scale5[] = { 0.0,136.5,273.0,409.5,477.75,614.25,750.75,819.0,955.5,1092.0,1228.5,1296.75,1433.25,1569.75,1638.0,1774.5,1911.0,2047.5,2115.75,2252.25,2388.75,2457.0,2593.5,2730.0,2866.5,2934.75,3071.25,3207.75,3276.0,3412.5,3549.0,3685.5,3753.75,3890.25,4026.75,4095.0,4231.5 };
const int Quantizer::hints5[] = { 0,7,14,21,28,35 };
// scl/RSH_etdiat_mixolydian.scl
// Mixolydian diatonic in equal temperament
const float Quantizer::scale6[] = { 0.0,136.5,273.0,341.25,477.75,614.25,682.5,819.0,955.5,1092.0,1160.25,1296.75,1433.25,1501.5,1638.0,1774.5,1911.0,1979.25,2115.75,2252.25,2320.5,2457.0,2593.5,2730.0,2798.25,2934.75,3071.25,3139.5,3276.0,3412.5,3549.0,3617.25,3753.75,3890.25,3958.5,4095.0,4231.5 };
const int Quantizer::hints6[] = { 0,7,14,21,28,35 };
// scl/RSH_etdiat_phrygian.scl
// Phrygian diatonic in equal temperament
const float Quantizer::scale7[] = { 0.0,68.25,204.75,341.25,477.75,546.0,682.5,819.0,887.25,1023.75,1160.25,1296.75,1365.0,1501.5,1638.0,1706.25,1842.75,1979.25,2115.75,2184.0,2320.5,2457.0,2525.25,2661.75,2798.25,2934.75,3003.0,3139.5,3276.0,3344.25,3480.75,3617.25,3753.75,3822.0,3958.5,4095.0,4163.25 };
const int Quantizer::hints7[] = { 0,7,14,21,28,35 };
// scl/RSH_etpent_bluesmajor.scl
// Blues major pentatonic in equal temperament
const float Quantizer::scale8[] = { 0.0,136.5,341.25,477.75,614.25,819.0,955.5,1160.25,1296.75,1433.25,1638.0,1774.5,1979.25,2115.75,2252.25,2457.0,2593.5,2798.25,2934.75,3071.25,3276.0,3412.5,3617.25,3753.75,3890.25,4095.0,4231.5 };
const int Quantizer::hints8[] = { 0,5,10,15,20,25 };
// scl/RSH_etpent_bluesminor.scl
// Blues minor pentatonic in equal temperament
const float Quantizer::scale9[] = { 0.0,204.75,341.25,546.0,682.5,819.0,1023.75,1160.25,1365.0,1501.5,1638.0,1842.75,1979.25,2184.0,2320.5,2457.0,2661.75,2798.25,3003.0,3139.5,3276.0,3480.75,3617.25,3822.0,3958.5,4095.0,4299.75 };
const int Quantizer::hints9[] = { 0,5,10,15,20,25 };
// scl/RSH_etpent_egyptian.scl
// Egyptian pentatonic in equal temperament
const float Quantizer::scale10[] = { 0.0,136.5,341.25,477.75,682.5,819.0,955.5,1160.25,1296.75,1501.5,1638.0,1774.5,1979.25,2115.75,2320.5,2457.0,2593.5,2798.25,2934.75,3139.5,3276.0,3412.5,3617.25,3753.75,3958.5,4095.0,4231.5 };
const int Quantizer::hints10[] = { 0,5,10,15,20,25 };
// scl/RSH_etpent_major.scl
// Major pentatonic in equal temperament
const float Quantizer::scale11[] = { 0.0,136.5,273.0,477.75,614.25,819.0,955.5,1092.0,1296.75,1433.25,1638.0,1774.5,1911.0,2115.75,2252.25,2457.0,2593.5,2730.0,2934.75,3071.25,3276.0,3412.5,3549.0,3753.75,3890.25,4095.0,4231.5 };
const int Quantizer::hints11[] = { 0,5,10,15,20,25 };
// scl/RSH_etpent_minor.scl
// Minor pentatonic in equal temperament
const float Quantizer::scale12[] = { 0.0,204.75,341.25,477.75,682.5,819.0,1023.75,1160.25,1296.75,1501.5,1638.0,1842.75,1979.25,2115.75,2320.5,2457.0,2661.75,2798.25,2934.75,3139.5,3276.0,3480.75,3617.25,3753.75,3958.5,4095.0,4299.75 };
const int Quantizer::hints12[] = { 0,5,10,15,20,25 };

const int Quantizer::notecount[] = { 62,37,37,37,37,37,37,37,27,27,27,27,27 };

const float *Quantizer::scales[] = { scale0,scale1,scale2,scale3,scale4,scale5,scale6,scale7,scale8,scale9,scale10,scale11,scale12 };
const int *Quantizer::hints[] = { hints0,hints1,hints2,hints3,hints4,hints5,hints6,hints7,hints8,hints9,hints10,hints11,hints12 };

const int Quantizer::bankandscale[12][12] = {
  {  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, // 12-equal
  {  1,  2,  3,  4,  5,  6,  7, -1, -1, -1, -1, -1 }, // diatonic modes
  {  8,  9, 10, 11, 12, -1, -1, -1, -1, -1, -1, -1 }, // pentatonic modes
  { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
  { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
  { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
  { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
  { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
  { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
  { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
  { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
  { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }
};

// END AUTOGENERATED SCALE CLASS DATA

